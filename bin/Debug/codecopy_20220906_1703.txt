
using System;
using System.Diagnostics.Metrics;
using System.Linq;
using System.Reflection;
using System.Reflection.PortableExecutable;
using System.Security.Cryptography;
using System.Text.Json;
using fh_res;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;


//Declare full path to signature JSON file
string signatureFilePath = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location) + "\\signatures.json";

//Declare list type signature into which the magic contents will be loaded
List<Signature> signature = new();

//Load magic text contents into signature object
LoadJson(signatureFilePath, ref signature);

//DisplayHeaders(ref signature);
//DisplayHeaders_SearchByExtension("xlsx", ref signature);
//DisplayHeaders_SearchByHex("4D5A", ref signature);
//GetFileType("C:\\Users\\Admin\\Desktop\\text.xlsx", ref signature);
//GetMoreFileDetails("C:\\Users\\Admin\\Desktop\\text.xlsx");
//PatchBytes("C:\\Users\\Admin\\Desktop\\text.xlsx", "86", ref signature);

//args[0] = "";
//args[1] = "--search-type ";

//switch (args[0])
//{
//    case "-h":
//        Console.WriteLine("\n----------------------------------------------------------------------------------------------------------");
//        Console.WriteLine("----------------------------------------------------------------------------------------------------------");
//        Console.WriteLine("----                                 FILE HEADER RESOLVER v1.0  (BETA)                                 ---");
//        Console.WriteLine("----------------------------------------------------------------------------------------------------------");
//        Console.WriteLine("----------------------------------------------------------------------------------------------------------");
//        Console.WriteLine("***NOTE:  Use at your own risk.  Patching header bytes can render the file unusable.  Always backup files ");
//        Console.WriteLine("          prior to using this tool.");
//        Console.WriteLine("\n{0,-25} {1,-32} {2,-50}", "Command/s", "Usage", "Notes");
//        Console.WriteLine("----------------------------------------------------------------------------------------------------------");
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "-ft (file type)", "-ft \"FilePath\"", "Get the file type");
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "", "", "Displays current header if no type is found");
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "-ft (file type) --more", "-ft \"FilePath\" --more", "Returns additional file information such as:");
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "", "", "basic file attributes including the MD5, SHA1,"); 
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "", "", "SHA256, SHA384 and SHA512 hashes");
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "-pb (patch byte/s)", "-pb \"FilePath\" \"FileIndex\"", "Patch the header starting at offset 0");
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "", "", "Use the -dh command to get the file index");
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "-dh (display header)", "-dh", "Return all stored headers");
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "-dh --search-ext", "-dh --search-ext \"keyword\"", "Case-insensitive search");
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "", "", "Contained within search e.g. \"if\" returns GIF");
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "-dh --search-hex", "-dh --search-hex \"hex value\\s\"", "Must be space seperated e.g. \"4D 5A\"");
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "", "", "Case-insensitive search");
//        Console.WriteLine("{0,-25} {1,-32} {2,-50}", "", "", "Contained within search e.g. \"4D\" returns 42 4D");
//        Console.WriteLine("-----------------------------------------------------------------------------------------------------------");
//        break;
//    case "-ft": DONE
//        if (args.Length == 2)
//        {
//            //Display File Type
//            GetFileType(args[1], ref signature); //arg[1]:  File path to get type of, arg[2]:  list of headers
//        }
//        else if (args.Length == 3)
//        {
//            if (args[2] == "--more") 
//            {
//                //Display File Type
//                GetFileType(args[1], ref signature); //arg[1]:  File path to get type of, arg[2]:  list of headers
//                GetMoreFileDetails(args[1]);
//            } //Serach by type }
//        }     
//        break;
//    case "-pb":
//        //Patch the file with the selected header from the header list
//        PatchBytes(args[1], args[2], ref signature);//arg[1]:  File path of file to patch, arg[2]:  Index of header to patch with, arg[3]:  list of headers
//        break;
//    case "-dh": DONE
//        //Display headers list
//        if (args.Length == 1)
//        {
//            DisplayHeaders(ref signature);//Display all headers
//        }
//        else if (args.Length == 3)
//        {
//            if (args[1] == "--search-ext") { DisplayHeaders_SearchByExtension(args[2], ref signature); } //Serach by type }
//            else if (args[1] == "--search-hex") { DisplayHeaders_SearchByHex(args[2], ref signature); } //Serach by hex }
//        }
//        break;
//    default:
//        Console.WriteLine("Error:  Unknown command!!!");
//        Console.WriteLine("Press enter to exit....");
//        Console.ReadLine();
//        break;
//}

static string HexToAscii(string hexValues, int lengthToPrint)
{
    string ascii = string.Empty;

    string hex= hexValues[..lengthToPrint]; //substring from 0 to lenght

    string[] splitValues = hex.Chunk(2).Select(x => new string(x)).ToArray();

    foreach (string hValue in splitValues)
    {
        int value = Convert.ToInt32(hValue, 16);
        if (value > 31) //ignore non-printable characters
        {
            char charValue = (char)value;
            ascii += charValue.ToString();
        }
    }

    return ascii;
}

///<summary>
///Load headers into the header list
/// </summary>
static void Load_Headers(string headerListFilePath, ref List<Header> headersList)
{
    int counter = 1;
    var magicBytes = File.ReadAllLines(@headerListFilePath);
    foreach (var magic in magicBytes)
    {
        string[] stagingArray = magic.Split(new Char[] { ',' }).ToArray();
        headersList.Add(new Header(counter, stagingArray[0], stagingArray[1])); 
        counter++;
    }
}


/// <summary>
/// Patch header from offset 0
/// </summary> 
static void PatchBytes(string args1, string args2, ref List<Signature> signature) //arg1 file arg2 index
{   
    using FileStream fs = File.OpenWrite(args1);
    
    int indexTemp = Convert.ToInt32(args2);
    var data = signature[indexTemp - 1].Hex;//.Replace(" ", ""); 
    byte[] buffer = Convert.FromHexString(data);
    fs.Write(buffer, 0, buffer.Length);
    Console.WriteLine("Patch Applied!!!");
}

/// <summary>
/// Display headers list
/// </summary>
static void DisplayHeaders(ref List<Signature> signature)
{
    Console.WriteLine("{0,-5} {1,-15} {2,-10} {3,-120} {4,-120} {5,-50}", "ID", "Extension", "Offset", "Signature","ASCII", "Mime");
    foreach (Signature signatureRow in signature)
    { //NOTE name is the extension
        Console.WriteLine("{0,-5} {1,-15} {2,-10} {3,-120} {4,-120} {5,-50}", signatureRow.Id, signatureRow.Name, signatureRow.Offset, signatureRow.Hex, HexToAscii(signatureRow.Hex, signatureRow.Hex.Length), signatureRow.Mime);
    }
}

static void DisplayHeaders_SearchByExtension(string keyWord, ref List<Signature> signature)
{ //NOTE name is the extension
    Console.WriteLine("{0,-5} {1,-15} {2,-10} {3,-120} {4,-120} {5,-50}", "ID", "Extension", "Offset", "Signature", "ASCII", "Mime");
    Console.WriteLine("----------------------------------------------------------------------------------------------");
    foreach (Signature tempSignature in signature.FindAll(x => (x.Name.ToLower().Contains(keyWord.ToLower())))) //Convert all input to lowercase for searching
    { 
        Console.WriteLine("{0,-5} {1,-15} {2,-10} {3,-120} {4,-120} {5,-50}", tempSignature.Id, tempSignature.Name, tempSignature.Offset, tempSignature.Hex, HexToAscii(tempSignature.Hex, tempSignature.Hex.Length), tempSignature.Mime); //Display only headers that were searched for
    }
    Console.WriteLine("----------------------------------------------------------------------------------------------");
}

static void DisplayHeaders_SearchByHex(string keyWord, ref List<Signature> signature)
{
    Console.WriteLine("{0,-5} {1,-15} {2,-10} {3,-120} {4,-120} {5,-50}", "ID", "Extension", "Offset", "Signature", "ASCII", "Mime");
    Console.WriteLine("----------------------------------------------------------------------------------------------");
    foreach (Signature tempSignature in signature.FindAll(x => (x.Hex.ToLower().Contains(keyWord.ToLower())))) //Convert all input to lowercase for searching
    {
        Console.WriteLine("{0,-5} {1,-15} {2,-10} {3,-120} {4,-120} {5,-50}", tempSignature.Id, tempSignature.Name, tempSignature.Offset, tempSignature.Hex, HexToAscii(tempSignature.Hex, tempSignature.Hex.Length), tempSignature.Mime); //Display only headers that were searched for
    }
    Console.WriteLine("----------------------------------------------------------------------------------------------");
}

static void GetMoreFileDetails(string fullPath)
{
    LocalFile localFile = new LocalFile(fullPath);
    Console.WriteLine("\n----------------------------------------------------------------------------------------------");
    Console.WriteLine("----------                   ADDITIONAL DETAILS                                   ------------");
    Console.WriteLine("----------------------------------------------------------------------------------------------");
    Console.WriteLine("{0,-15} {1,-64}", "File Name:" , localFile.Name);
    Console.WriteLine("{0,-15} {1,-64}", "File Size:" , localFile.FileSize + " bytes");
    Console.WriteLine("{0,-15} {1,-64}", "Created Date:" , localFile.CreatedDate );
    Console.WriteLine("{0,-15} {1,-64}", "Accessed Date:" , localFile.LastAccessed );
    Console.WriteLine("{0,-15} {1,-64}", "Modified Date:", localFile.LastModifiedDate );
    Console.WriteLine("{0,-15} {1,-64}", "MD5:", localFile.MD5HashValue);
    Console.WriteLine("{0,-15} {1,-64}", "SHA1:" , localFile.Sha1HashValue);
    Console.WriteLine("{0,-15} {1,-64}", "SHA256:" , localFile.Sha256HashValue);
    Console.WriteLine("{0,-15} {1,-64}", "SHA384:" , localFile.Sha384HashValue);
    Console.WriteLine("{0,-15} {1,-64}", "SHA512:" , localFile.Sha512HashValue);
    Console.WriteLine("----------------------------------------------------------------------------------------------");
}

/// <summary>
/// Display File Type
/// </summary>
static void GetFileType(string args1, ref List<Signature> signature)
{
    const int HEADER_SIZE = 64;
    byte[] bytesFile = new byte[HEADER_SIZE];

    using (FileStream fs = File.OpenRead(args1))//@argFilePath
    {
        fs.Read(bytesFile, 0, HEADER_SIZE);
        fs.Close();
    }

    //Convert the byte file to its hex string representation
    string header = BitConverter.ToString(bytesFile).Replace("-", "");
    Console.WriteLine("\n----------------------------------------------------------------------------------------------");
    Console.WriteLine("----------                            FILE TYPE                                   ------------");
    Console.WriteLine("----------------------------------------------------------------------------------------------");

    try
    {
        var query = signature.Where(x => header.StartsWith(x.Hex));

        Console.WriteLine($"\nFile:  {args1}");
        Console.WriteLine($"Total Matches Found:  {query.Count()}");

        foreach (Signature sig in query)
        {
            Console.WriteLine("\n{0,-15} {1,-64}", "Hexadecimal:", sig.Hex);
            Console.WriteLine("{0,-15} {1,-64}", "ASCII:", HexToAscii(header, sig.Hex.Length)); //header.Substring(0,query.HexValues.Length));header[..query.HexValues.Length])
            Console.WriteLine("{0,-15} {1,-64}", "Extension:", sig.Name);
        }
    }
    catch (InvalidOperationException)
    {
        Console.WriteLine("Cannot find exact matching header!!!");
        Console.WriteLine("Current Header Information: (Displaying 16 bytes from offset 0)"); //catered for 4 spaces conatined in the header variable
        Console.WriteLine("{0,-15} {1,-64}", "Hexadecimal:", header[..20]);
        Console.WriteLine("{0,-15} {1,-64}", "ASCII:", HexToAscii(header, 20));
    }
    catch (Exception ex)
    {
        Console.WriteLine("Error info:" + ex.Message);
        Console.WriteLine("Press enter to exit....");
        Console.ReadLine();
    }
    finally
    {
        Console.WriteLine("----------------------------------------------------------------------------------------------");
    }
}

static void LoadJson(string signatureListFilePath, ref List<Signature> signatureList)
{
    List<StagingSignature> stagingSignature = new();

    using (StreamReader r = new(signatureListFilePath))
    {
        string json = r.ReadToEnd(); //read the JSON file
        var jo = JObject.Parse(json); //initialise an object to iterate through the nodes

        foreach (var kv in jo)
        {
            if (kv.Value!=null)
            {
                var deserializable = kv.Value.ToString(); //get deserializable children

                if (kv.Key != null) //Get the Name.  Name is the root node e.g. 123
                {
                    var sign = JsonConvert.DeserializeObject<StagingSignature>(deserializable);
                    sign.Name = kv.Key;
                    stagingSignature.Add(sign);//deserialise each node and add to signature object
                }
            }            
        }

        int stagingCounter = 1;
        foreach (StagingSignature signs in stagingSignature)
        {

            foreach (var val in signs.Signs) //access signature list attribute
            {
                int offset = Convert.ToInt32(val[..val.IndexOf(',')]); //substring(0,1)
                string hexValue = val.Substring(val.IndexOf(',')+1); //substring(2)
                signatureList.Add(new Signature() { Id = stagingCounter, Name = signs.Name, Offset = offset, Hex  = hexValue, Mime = signs.Mime });
                stagingCounter++;
            }
        }

        r.Close();
    }





}
